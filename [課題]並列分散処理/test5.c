#include  <stdio.h>#include <stdlib.h>#include <math.h>#include "MT.h"#include <time.h>#include <mpi.h>void RadixSort(int x[ ], int n, int r);void ShowData(unsigned long x[ ], int n);#define NUM_DATA 15000#define M 2#define MASK 1void ShowData(unsigned long x[ ], int n){	int i;	for (i = 0; i < n ; i++)		printf("%ld\n", x[i]);}void ShowData2(int x[ ], int n){	int i;	for (i = 0; i < n ; i++)		printf("%d\n", x[i]);}int array_add(unsigned long array[], unsigned long add){	int e_size = 0;	array[e_size] = add;	e_size = e_size + 1;	return e_size;}voidradix_sort(unsigned long *array, unsigned int size){    int i, bit;     int count[M];     unsigned int buf[NUM_DATA]; 	for(bit = 0; bit < 30; bit += 1){         /* 度数分布を求める */		for(i = 0; i < M; ++i) count[i] = 0; 		for(i = 0; i < size; ++i){ ++count[(array[i] >> bit) & MASK];}		//printf("%d:\n", count[1]);		for(i = 1; i < M; ++i) count[i] += count[i-1]; 		/* 度数分布に従ってデータを整列する */        for(i = size-1; i>=0; --i){			buf[--count[(array[i] >> bit) & MASK]] = array[i];		}        for(i=0; i<size; ++i) array[i] = buf[i];     } }int bitcount(unsigned long n){    n = n - ((n >> 1) & 033333333333) - ((n >> 2) & 011111111111);    return ((n + (n >> 3)) & 030707070707) % 077 +10;}int bit_max(unsigned long n[ ]){	int i,max=0;	for(i=0;i<NUM_DATA;i++){		if(bitcount(n[i])>max){			max=bitcount(n[i]);		}	}	return max;}int main(int argc, char *argv[]){	clock_t start,end;	unsigned long data[NUM_DATA],array[NUM_DATA];	int i,bit,max_b;	int count[NUM_DATA];	int size=NUM_DATA;	int count2[M];	int count3[50]={0};	unsigned long buf[size];		/* 乱数生成 */	init_genrand((unsigned int)time(NULL));	for(i=0;i<NUM_DATA;i++){  		array[i]=genrand_int32();	}	start = clock();	bit=31;		/* 度数分布を求める */		//ShowData(array, size);		for(i = 0; i < M; ++i) count[i] = 0; 		for(i = 0; i < size; ++i){ ++count[(array[i] >> bit) & MASK];}		for(i = 0; i < M; ++i) count2[i] = count[i];		for(i = 1; i < M; ++i) count[i] += count[i-1];		/* 度数分布に従ってデータを整列する */		for(i = size-1; i>=0; --i){			buf[--count[(array[i] >> bit) & MASK]] = array[i];		}		for(i=0; i<size; ++i) array[i] = buf[i]; 		unsigned long buf0[count2[0]];		unsigned long buf1[count2[1]];		int k=0,l=0;		for(i=0;i<size;i++){		if(i<count2[0]){			buf0[k]=array[i];			k++;		}else{			//printf("%ld ::\n",array[i]);			buf1[l]=array[i];			l++;		}	}	int size1=count2[0];	int size2=count2[1];	//ShowData2(count2, 2);	//ShowData(buf0, size1);	//ShowData(buf1, size2);	bit=30;	//buf0		for(i = 0; i < M; ++i) count[i] = 0; 		for(i = 0; i < size1; ++i){ ++count[(buf0[i] >> bit) & MASK];}		for(i = 0; i < M; ++i) count2[i] = count[i];		for(i = 1; i < M; ++i) count[i] += count[i-1];			/* 度数分布に従ってデータを整列する */	for(i = size1-1; i>=0; --i){		buf[--count[(buf0[i] >> bit) & MASK]] = buf0[i];	}	//ShowData(buf,size);	for(i=0; i<size1; ++i) buf0[i] = buf[i]; 	unsigned long buf00[count2[0]];	unsigned long buf11[count2[1]];	count3[0]=count2[0];	count3[1]=count2[1];	k=0;	l=0;	for(i=0;i<size1;i++){		if(i<count2[0]){			buf00[k]=buf0[i];			k++;		}else{			buf11[l]=buf0[i];			l++;		}	}		//buf1		for(i = 0; i < M; ++i) count[i] = 0; 		for(i = 0; i < size2; ++i){ ++count[(buf1[i] >> bit) & MASK];}		for(i = 0; i < M; ++i) count2[i] = count[i];		for(i = 1; i < M; ++i) count[i] += count[i-1];				/* 度数分布に従ってデータを整列する */		//printf("%d : \n",count[1]);		//ShowData2(count, 2);	//ShowData(array,size);		for(i = size2-1; i>=0; --i){			buf[--count[(buf1[i] >> bit) & MASK]] = buf1[i];		}	//ShowData(buf,size);		for(i=0; i<size2; ++i) buf1[i] = buf[i]; 	unsigned long buf22[count2[0]];	unsigned long buf33[count2[1]];	count3[2]=count2[0];	count3[3]=count2[1];	k=0;	l=0;		for(i=0;i<size2;i++){		if(i<count2[0]){			buf22[k]=buf1[i];			k++;		}else{			buf33[l]=buf1[i];			l++;		}	}	int numprocs, rank, namelen;	char processor_name[MPI_MAX_PROCESSOR_NAME];	unsigned long d[NUM_DATA];	unsigned long rece_d[NUM_DATA];	radix_sort(buf00, count3[0]);	for(i=0;i<count3[0];i++){			d[i]=buf00[i];		}	radix_sort(buf11, count3[1]);	for(i=count3[0];i<count3[0]+count3[1];i++){			d[i]=buf11[i-count3[0]];	}	radix_sort(buf22, count3[2]);			for(i=count3[0]+count3[1];i<count3[0]+count3[1]+count3[2];i++){			d[i]=buf22[i-count3[0]-count3[1]];	}	radix_sort(buf33, count3[3]);			for(i=count3[0]+count3[1]+count3[2];i<count3[0]+count3[1]+count3[2]+count3[3];i++){		d[i]=buf33[i-count3[0]-count3[1]-count3[2]];		}		radix_sort(array, NUM_DATA);	//ShowData(array,NUM_DATA);	/*	if(rank == 0){		radix_sort(buf00, count3[0]);		for(i=0;i<count3[0];i++){			d[i]=buf00[i];		}	}else if(rank == 1){		radix_sort(buf11, count3[1]);		for(i=count3[0];i<count3[0]+count3[1];i++){			d[i]=buf11[i-count3[0]];		}	}else if(rank == 2){			radix_sort(buf22, count3[2]);			for(i=count3[0]+count3[1];i<count3[0]+count3[1]+count3[2];i++){			d[i]=buf22[i-count3[0]-count3[1]];		}	}else if(rank == 3){			radix_sort(buf33, count3[3]);			for(i=count3[0]+count3[1]+count3[2];i<count3[0]+count3[1]+count3[2]+count3[3];i++){		d[i]=buf33[i-count3[0]-count3[1]-count3[2]];		}	}MPI_Status st;if(3==rank){	MPI_Send(buf33,count3[3], MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);}else if(2==rank){	MPI_Send(buf22,count3[2], MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);}else if(1==rank){	MPI_Send(buf11,count3[1], MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);}else if(0==rank){	MPI_Recv(rece_d, count3[1], MPI_UNSIGNED_LONG, 1, 0, MPI_COMM_WORLD, &st);	for(i=count3[0];i<count3[0]+count3[1];i++){	d[i]=rece_d[i-count3[0]];}	MPI_Recv(rece_d, count3[2], MPI_UNSIGNED_LONG, 2, 0, MPI_COMM_WORLD, &st);//ShowData(rece_d, count3[2]);for(i=count3[0]+count3[1];i<count3[0]+count3[1]+count3[2];i++){			d[i]=rece_d[i-count3[0]-count3[1]];		}	MPI_Recv(rece_d, count3[3], MPI_UNSIGNED_LONG, 3, 0, MPI_COMM_WORLD, &st);//ShowData(rece_d, count3[3]);for(i=count3[0]+count3[1]+count3[2];i<count3[0]+count3[1]+count3[2]+count3[3];i++){		d[i]=rece_d[i-count3[0]-count3[1]-count3[2]];		}}	if(rank == 0){		ShowData(d, NUM_DATA);	}	MPI_Finalize();*/	//ShowData(d, NUM_DATA);	end = clock();	printf("処理時間: %.8f秒\n",(double)(end-start)/CLOCKS_PER_SEC);}